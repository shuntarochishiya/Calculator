ORG 00H
	; восьмибитный калькулятор
	; R0 используется для команд и данных (на LCD)
	; R1 сохраняет первое число
	; R2 сохраняет операцию
	; R3 сохраняет второе число
	; порт P3 - ввод с клавиатуры
	; порт P2 - сброс + два контакта LCD
	; порт P1 - выход LCD
	NEWNUM EQU P2.7 ; P2.7 высокий уровень при записи второго числа
	NEWDIG EQU P2.6 ; P2.6 низкий уровень только при записи первой цифры числа
	RS EQU P2.1 ; RS на LCD
	RW EQU P2.2 ; RW на LCD

	; команды для подготовки LCD к записи
	
	MOV R0, #38H     	; использует 2 линии и матрицу 5х7
	ACALL COMMAND    	; вызывает программу для управления LCD
	MOV R0, #0EH   		; включить дисплей/отобразить курсор
	ACALL COMMAND    	
	MOV R0, #80H   		; разместить курсор на первой линии
	ACALL COMMAND  		
	MOV R0, #01H     	; очистить экран дисплея
	ACALL COMMAND		
	
	MOV R4, #00H   		; сброс регистра R4
	MOV P2, #00H		; сброс порта P2
	MOV P3, #0FEH		; запуск LCD на земле (линия 1 активна)
	MOV R3, #00H		; сброс регистра R3
	MOV R1, #00H		; сброс регистра R1
	MOV R2, #'+'		; на случай, если вводится только 1 цифра или только "равно"
L1:	
	JNB P3.0, C1		; переход к C1, если оно 0 (всегда начинается с 0)
	JNB P3.1, C2		; переход к C2, если оно 0
	JNB P3.2, C3		; переход к C3, если оно 0
	JNB P3.3, C4		; переход к C4, если оно 0
	SJMP L1			; возврат к проверке линий
	
C1:	JNB P3.4, SKIP_BUT_ON		; пропуск, если нажата кнопка включения
	JNB P3.5, SKIP_BUT_ZERO		; пропуск, если нажата кнопка "0"
	JNB P3.6, SKIP_BUT_EQUALS	; пропуск, если нажата кнопка "="
	JNB P3.7, SKIP_BUT_ADD	; пропуск, если нажата кнопка "+"
	SETB P3.0			; отключение линии 1
	CLR P3.1			; включение линии 1
	SJMP L1				; возврат к проверке линий
	

C2:	JNB P3.4, SKIP_BUT_1		; пропуск, если нажата кнопка "1"
	JNB P3.5, SKIP_BUT_2		; пропуск, если нажата кнопка "2"
	JNB P3.6, SKIP_BUT_3		; пропуск, если нажата кнопка "3"
	JNB P3.7, SKIP_BUT_MINUS	; пропуск, если нажата кнопка "-"
	SETB P3.1			; отключение линии 2
	CLR P3.2			; активация линии 3
	SJMP L1				; возврат к проверке линий
	
C3:	JNB P3.4, SKIP_BUT_4		; пропуск, если нажата кнопка "4"
	JNB P3.5, SKIP_BUT_5		; пропуск, если нажата кнопка "5"
	JNB P3.6, SKIP_BUT_6		; пропуск, если нажата кнопка "6"
	JNB P3.7, SKIP_BUT_MULT	; пропуск, если нажата кнопка "х"
	SETB P3.2			; отключение линии 3
	CLR P3.3			; активация линии 4
	SJMP L1				; возврат к проверке линий

C4:	JNB P3.4, SKIP_BUT_7		; пропуск, если нажата кнопка "7"
	JNB P3.5, SKIP_BUT_8		; пропуск, если нажата кнопка "8"
	JNB P3.6, SKIP_BUT_9		; пропуск, если нажата кнопка "9"
	JNB P3.7, SKIP_BUT_DIVIDE	; пропуск, если нажата кнопка "/"
	SETB P3.3			; отключение линии 4
	CLR P3.0			; активация линии 1
	LJMP L1				; возврат к проверке линий

SKIP_BUT_ON: LJMP BUT_ON		
SKIP_BUT_ZERO: LJMP BUT_ZERO		
SKIP_BUT_1: LJMP BUT_1			
SKIP_BUT_2: LJMP BUT_2			
SKIP_BUT_3: LJMP BUT_3			
SKIP_BUT_4: LJMP BUT_4			
SKIP_BUT_5: LJMP BUT_5			
SKIP_BUT_6: LJMP BUT_6			
SKIP_BUT_7: LJMP BUT_7			
SKIP_BUT_8: LJMP BUT_8			
SKIP_BUT_9: LJMP BUT_9			
SKIP_BUT_ADD: LJMP BUT_ADD		
SKIP_BUT_MINUS: LJMP BUT_MINUS		
SKIP_BUT_MULT: LJMP BUT_MULT		
SKIP_BUT_DIVIDE: LJMP BUT_DIVIDE	
SKIP_BUT_EQUALS: LJMP BUT_EQUALS		

BUT_ON: 	SETB P2.0	; включение или сброс
		LJMP L1		

BUT_ZERO: 	MOV R0, #'0'	; перемещение символа "0" на R0
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение числа на LCD
		LJMP L1		

BUT_EQUALS: 	MOV R0, #'='	; перемещение символа "=" на R0	
		ACALL DISPLAY	; отображение на экране
		ACALL RESULT	; реализация операции
		LJMP L1		

BUT_ADD: 	MOV R0, #'+'	; перемещение символа "+" на R0	
		ACALL OPERATION	; сохранение оерации в R2
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_1: 		MOV R0, #'1'	; перемещение символа "1" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_2: 		MOV R0, #'2'	; перемещение символа "2" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_3: 		MOV R0, #'3'	; перемещение символа "3" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_MINUS: 	MOV R0, #'-'	; перемещение символа "-" в R0	
		ACALL OPERATION	; сохранение операции в R2
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_4: 		MOV R0, #'4'	; перемещение символа "4" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_5: 		MOV R0, #'5'	; перемещение символа "5" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_6: 		MOV R0, #'6'	; перемещение символа "6" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_MULT: 	MOV R0, #'*'	; перемещение символа "*" в R0	
		ACALL OPERATION	; сохранение операции в R2
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_7: 		MOV R0, #'7'	; перемещение символа "7" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_8: 		MOV R0, #'8'	; перемещение символа "8" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_9: 		MOV R0, #'9'	; перемещение символа "9" в R0	
		ACALL NUMBER	; сохранение числа
		ACALL DISPLAY	; отображение на экране
		LJMP L1		

BUT_DIVIDE: 	MOV R0, #'/'	; перемещение символа "/" в R0	
		ACALL OPERATION	; сохранение операции в R2
		ACALL DISPLAY	; отображение на экране
		LJMP L1		


DISPLAY:   
	MOV P1, R0	; перемещение символа на выход (P1) 
	SETB RS    	; размещает RS (Register Select) в режиме данных
	SETB RW     	; дает разрешение на чтение/запись на LCD (высокий уровень)
	CLR RW 	
	ACALL DELAY  	; вызов с задержкой 0.25с
	RET 		

COMMAND:   
	MOV P1, R0  	; перемещение управления на выход - входной порт LCD 
	CLR RS     	; перевод RS (Register Select) в режим управления
	SETB RW    	; дает разрешение на чтение/запись на LCD (высокий уровень)
	CLR RW	
	ACALL DELAY	; вызов с задержкой 0.25с
	RET    		


NUMBER: 
	JB NEWNUM, SECONDNUM	; пропуск, если это второе число
	JB NEWDIG, NEWDIGIT	; пропуск, если не первая цифра первого числа
	MOV A, R0		; перенос символа в аккумулятор
	SUBB A, #30H		; преобразование этого символа в цифровой эквивалент
	MOV R1, A		; сохраняет число в регистре R1
	SETB NEWDIG		; установить пин "NEWDIG" => первая цифра первого числа сохранена
	RET			

NEWDIGIT: 
	MOV A, R0			; переместить новый символ в аккумулятор
	MOV B, #10D			; перемещение константы 10 во вспомогательный аккумулятор
	SUBB A, #30H			; преобразование этого символа в цифровой эквивалент
	MOV R7, A			; перемещение результата в регистр R7
	MOV A, R1			; перемещение текущего числа (первое число) в аккумулятор
	MUL AB				; умножение текущего числа на 10
	MOV R6, B 			; сохранение значащей части в регистре R6
	CJNE R6, #00H, JUMP_OVERFLOW	; если есть значение B или R6, то значит идет превышение 8 бит
	ADD A, R7			; если не превышает, умножаем текущее число на 10
	JC JUMP_OVERFLOW		; если перенос равен 1, то идет превышение 8 бит (переход к метке OVERFLOW)
	MOV R1, A			; переместить результат из первого числа в регистр R1
	SETB NEWDIG			; установить пин "NEWDIG" => сохранение нового числа
	RET				
	
SECONDNUM:
	JB NEWDIG, NEWDIGIT2	; пропуск, если это не первая цифра второго числа
	MOV A, R0		; перемещение числа в аккумулятор
	SUBB A, #30H		; преобразование этого символа в цифровой эквивалент
	MOV R3, A		; сохранение этого числа в регистре R3
	SETB NEWDIG		; установить пин "NEWDIG" => первая цифра второго числа сохранена
	RET			; возврат

NEWDIGIT2: 
	MOV A, R0		; переместить новый символ в аккумулятор
	MOV B, #10D		; перемещение константы 10 во вспомогательный аккумулятор
	SUBB A, #30H		; преобразование этого символа в цифровой эквивалент
	MOV R7, A		; перемещение результата в регистр R7
	MOV A, R3		; перемещение текущего числа (второе число) в аккумулятор
	MUL AB			; умножение текущего числа на 10
	MOV R6, B 		; сохранение значащей части в регистре R6
	CJNE R6, #00H, JUMP_OVERFLOW	; если есть значение B или R6, то значит идет превышение 8 бит
	ADD A, R7			; если не превышает, умножаем текущее число на 10
	JC JUMP_OVERFLOW		; если перенос равен 1, то идет превышение 8 бит (переход к метке OVERFLOW)
	MOV R3, A			; переместить результат из первого числа в регистр R1
	SETB NEWDIG			; установить пин "NEWDIG" => сохранение нового числа
	RET				

OPERATION:
	SETB NEWNUM		; "NEWNUM" указывает на то, что начинается следующее число
	CLR NEWDIG		; очистка "NEWDIG" указывает на то, что следующая цифра будет первой
	MOV A, R0		; перемещение символа операции в аккумулятор
	MOV R2, A		; перемещение символа операции в регистр R2
	RET			


RESULT:
	CJNE R2, #'+', SUBSTRACT	; проверка, что операция - сложение
	MOV A, R1			; перемещение первого числа в аккумулятор
	CLR C 				; чистка переноса
	ADD A, R3			; сложение двух чисел
	JC JUMP_OVERFLOW		; если перенос равен 1, то идет превышение 8 бит (переход к метке OVERFLOW)
	MOV R5, #0H			; переместить 0 в регистр R5 (остальное - недесятичное)
	MOV R4, A			; сохранить результат суммы в регистре R4
	LJMP PRINT			; переход к метке PRINT
SUBSTRACT: 
	CJNE R2, #'-', MULTIPICATION	; проверка, что операция - вычитание
	MOV A, R1			; перемещение первого числа в аккумулятор
	CLR C 				; чистка переноса
	SUBB A, R3			; вычесть второе число из первого
	JC JUMP_OVERFLOW		; если перенос равен 1, то идет превышение 8 бит (переход к метке OVERFLOW)
	MOV R5, #0H			; переместить 0 в регистр R5 (остальное - недесятичное)
	MOV R4, A			; сохранить результат суммы в регистре R4
	LJMP PRINT			; переход к метке PRINT
	
MULTIPICATION:
	CJNE R2, #'*', DIVIDE		; проверка, что операция - умножение
	MOV A, R1			; перемещение первого числа в аккумулятор
	MOV B, R3			; перемещение второго числа во вспомогательный аккумулятор
	MUL AB				; умножение двух чисел
	MOV R7, B 			; сохранение значащей части в регистре R7
	CJNE R7, #0H, OVERFLOW		; если есть значение B или R6, то значит идет превышение 8 бит
	MOV R5, #0H			; переместить 0 в регистр R5 (остальное - недесятичное)
	MOV R4, A			; сохранить результат суммы в регистре R4
	LJMP PRINT			; переход к метке PRINT
	
DIVIDE:				; операция деления
	MOV A, R1			; перемещение первого числа в аккумулятор
	MOV B, R3			; перемещение второго числа во вспомогательный аккумулятор
	DIV AB				; разделить первое число на второе
	MOV R4, A			; сохранить результат суммы в регистре R4
	MOV R5, B 			; сохранение значащей части в регистре R5
	LJMP PRINT			; переход к метке PRINT

JUMP_OVERFLOW: 	LJMP OVERFLOW		; метка с длинным переходом на метку OVERFLOW
		

PRINT:
	CJNE R3, #0D, NORMAL		; переход, если второе число не равно нулю
	CJNE R2, #'/', NORMAL		; переход, если операция не деление
	MOV R0, #0C0H			; установить курсор на вторую строку
	ACALL COMMAND			; вызов подпрограммы для выполнения команды на LCD
	MOV DPTR, #MSGERRO		; перемещение адреса вектора в регистр DPTR (деление на ноль)
	CLR C				; очистка флага переноса
	MOV R7, #0D			; переместить 0 в регистр R7
PROX:	MOV A, R7			; переместить содержимое R7 в аккумулятор
	MOVC A, @A+DPTR			; переместить содержимое, адресованное A+DPTR, в аккумулятор
	MOV R0, A			; переместить результат в регистр R0
	ACALL DISPLAY			; вывод на LCD
	INC R7				; если не ноль, увеличить R7
	JNZ PROX			; если не ноль, переход на метку prox
	RET				
					
NORMAL:	MOV R7, #100D			; переместить константу 100 в регистр R7
	CLR C 				; очистка флага переноса (чтобы не мешать вычитанию)
	SUBB A, R7			; вычесть 100 из результата
	JC LESS100			; если флаг переноса установлен, результат < 100 - переход на метку LESS100
	MOV A, R4			; переместить результат в аккумулятор снова (трёхзначное число)
	MOV B, R7			; переместить константу 100 в регистр вспомогательного аккумулятора
	DIV AB				; разделить результат на 100 для получения третьей цифры
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (сотни)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (сотни)
	MOV R4, B 			; переместить остаток от деления на 100 в R4			
	MOV A, B 			; переместить остаток от деления на 100 в аккумулятор
	MOV R7, #10D			; переместить константу 10 в регистр R7
	MOV B, R7			; переместить константу 10 в регистр вспомогательного аккумулятора
	DIV AB				; разделить остаток от деления на 100 на 10
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (десятки)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (десятки)
	MOV A, B			; переместить остаток от деления на 10 в аккумулятор
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (единицы)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (единицы)
	CJNE R5, #00H, DECIMAL		; если остаток от операции деления не равен 0, переход на метку DECIMAL
	RET
	
LESS100: MOV R7, #10D			; переместить константу 10 в регистр R7
	CLR C 				; очистка флага переноса (чтобы не мешать вычитанию)
	MOV A, R4			; переместить результат в аккумулятор
	SUBB A, R7			; вычесть 10 из результата
	JC LESS10			; если флаг переноса установлен, результат < 10 - переход на метку LESS10
	MOV A, R4			; переместить результат в аккумулятор снова (двузначное число)
	MOV B, R7			; переместить константу 10 в вспомогательный аккумулятор
	DIV AB				; разделить результат на 10 для получения второй цифры
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (десятки)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (десятки)
	MOV A, B 			; переместить остаток от деления на 10 в аккумулятор
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (единицы)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (единицы)
	CJNE R5, #00H, DECIMAL		; если остаток от операции деления не равен 0, переход на метку DECIMAL
	RET				

LESS10:
	MOV A, R4			; переместить результат в аккумулятор
	ADD A, #30H			; преобразовать число в соответствующий символ
	MOV R0, A			; переместить символ в регистр R0 (единицы)
	ACALL DISPLAY			; вызов подпрограммы для вывода символа на экран LCD (единицы)
	CJNE R5, #00H, DECIMAL		; если остаток от операции деления не равен 0, переход на метку DECIMAL
	RET				


OVERFLOW:
	MOV R0, #0C0H		; установить курсор на вторую строку
	ACALL COMMAND		; вызов подпрограммы для выполнения команды на LCD
	MOV DPTR, #MSGERRO2	; переместить адрес вектора в регистр DPTR
	CLR C			; очистка флага переноса
	MOV R7, #0D		; переместить 0 в регистр R7
PROX2:	MOV A, R7		; переместить содержимое R7 в аккумулятор
	MOVC A, @A+DPTR		; переместить содержимое, адресованное A+DPTR, в аккумулятор
	MOV R0, A		; переместить результат в регистр R0
	ACALL DISPLAY		; вызов подпрограммы для вывода символа на экран LCD
	JZ FIN			; когда достигнуто нуля, переход на метку FIN
	INC R7			; если не ноль, увеличить R7
	SJMP PROX2		; переход к метке PROX2 (цикл для вывода сообщения)
FIN:	
	RET			


DECIMAL: MOV R0, #'.'		; переместить символ "." в регистр R0
	ACALL DISPLAY		; вызов подпрограммы для вывода символа на экран LCD
	MOV A, R5		; переместить остаток деления в аккумулятор
	MOV B, #10D		; переместить константу 10 во вспомогательный аккумулятор
	MUL AB			; умножить остаток деления на 10
	MOV B, R3		; переместить делитель (второе число) во вспомогательный аккумулятор
	DIV AB			; разделить (остаток*10) на второе число снова
	ADD A, #30H		; преобразовать число в соответствующий символ
	MOV R0, A		; переместить символ в регистр R0 (десятичная часть)
	ACALL DISPLAY		; вызов подпрограммы для вывода символа на экран LCD (единицы)
	RET			


DELAY:	MOV 62, #2		; задержка 0.25 секунды
DELAY1:	MOV 61, #250
DELAY2:	MOV 60, #250	
	DJNZ 60, $
	DJNZ 61, DELAY2
	DJNZ 62, DELAY1
	RET

; DB - определение байта (инициализация памяти)
MSGERRO: DB 'ERRO: DIV BY 0',0		; вектор сообщения об ошибке - деление на ноль!
MSGERRO2: DB 'OVERFLOW!',0		; вектор сообщения об ошибке - переполнение 8 бит/отрицательное число

	END
